{"ast":null,"code":"import * as i1 from '@angular/common/http';\nimport { HttpRequest, HttpResponse, HttpHeaders, HttpParams } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Optional, PLATFORM_ID, Inject, NgModule } from '@angular/core';\nimport { of, isObservable, throwError } from 'rxjs';\nimport { filter, map, retry, shareReplay, catchError, concatMap, take } from 'rxjs/operators';\nimport * as vlq from 'vlq';\nimport * as i1$1 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\n/**\r\n * Injection token of logger config\r\n */\n\nconst TOKEN_LOGGER_CONFIG = 'TOKEN_LOGGER_CONFIG';\n\nclass NGXLoggerConfigEngine {\n  constructor(config) {\n    this.config = this._clone(config);\n  }\n  /** Get a readonly access to the level configured for the NGXLogger */\n\n\n  get level() {\n    return this.config.level;\n  }\n  /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\n\n\n  get serverLogLevel() {\n    return this.config.serverLogLevel;\n  }\n\n  updateConfig(config) {\n    this.config = this._clone(config);\n  }\n  /** Update the config partially\r\n   * This is useful if you want to update only one parameter of the config\r\n   */\n\n\n  partialUpdateConfig(partialConfig) {\n    // avoid any error if the config is incorrect\n    if (!partialConfig) {\n      return;\n    }\n\n    Object.keys(partialConfig).forEach(configParamKey => {\n      this.config[configParamKey] = partialConfig[configParamKey];\n    });\n  }\n\n  getConfig() {\n    return this._clone(this.config);\n  } // TODO: This is a shallow clone, If the config ever becomes hierarchical we must make this a deep clone\n\n\n  _clone(object) {\n    const cloneConfig = {\n      level: null\n    };\n    Object.keys(object).forEach(key => {\n      cloneConfig[key] = object[key];\n    });\n    return cloneConfig;\n  }\n\n}\n/**\r\n * Injection token of logger config engine factory\r\n */\n\n\nconst TOKEN_LOGGER_CONFIG_ENGINE_FACTORY = 'TOKEN_LOGGER_CONFIG_ENGINE_FACTORY';\n\nclass NGXLoggerConfigEngineFactory {\n  provideConfigEngine(config) {\n    return new NGXLoggerConfigEngine(config);\n  }\n\n}\n/**\r\n * Injection token of logger mapper service\r\n */\n\n\nconst TOKEN_LOGGER_MAPPER_SERVICE = 'TOKEN_LOGGER_MAPPER_SERVICE';\n\nclass NGXLoggerMapperService {\n  constructor(httpBackend) {\n    this.httpBackend = httpBackend;\n    /** cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map' */\n\n    this.sourceMapCache = new Map();\n    /** cache for specific log position, key is the dist position, ie 'main.js:339:21' */\n\n    this.logPositionCache = new Map();\n  }\n  /**\r\n   * Returns the log position of the caller\r\n   * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the position\r\n   * @param config\r\n   * @param metadata\r\n   * @returns\r\n   */\n\n\n  getLogPosition(config, metadata) {\n    const stackLine = this.getStackLine(config); // if we were not able to parse the stackLine, just return an empty Log Position\n\n    if (!stackLine) {\n      return of({\n        fileName: '',\n        lineNumber: 0,\n        columnNumber: 0\n      });\n    }\n\n    const logPosition = this.getLocalPosition(stackLine);\n\n    if (!config.enableSourceMaps) {\n      return of(logPosition);\n    }\n\n    const sourceMapLocation = this.getSourceMapLocation(stackLine);\n    return this.getSourceMap(sourceMapLocation, logPosition);\n  }\n  /**\r\n   * Get the stackline of the original caller\r\n   * @param config\r\n   * @returns null if stackline was not found\r\n   */\n\n\n  getStackLine(config) {\n    const error = new Error();\n\n    try {\n      // noinspection ExceptionCaughtLocallyJS\n      throw error;\n    } catch (e) {\n      try {\n        // Here are different examples of stacktrace \n        // Firefox (last line is the user code, the 4 first are ours):\n        // getStackLine@http://localhost:4200/main.js:358:23\n        // getCallerDetails@http://localhost:4200/main.js:557:44\n        // _log@http://localhost:4200/main.js:830:28\n        // debug@http://localhost:4200/main.js:652:14\n        // handleLog@http://localhost:4200/main.js:1158:29\n        // Chrome and Edge (last line is the user code):\n        // Error\n        // at Function.getStackLine (ngx-logger.js:329)\n        // at NGXMapperService.getCallerDetails (ngx-logger.js:528)\n        // at NGXLogger._log (ngx-logger.js:801)\n        // at NGXLogger.info (ngx-logger.js:631)\n        // at AppComponent.handleLog (app.component.ts:38)\n        let defaultProxy = 4; // We make 4 functions call before getting here\n\n        const firstStackLine = error.stack.split('\\n')[0];\n\n        if (!firstStackLine.includes('.js:')) {\n          // The stacktrace starts with no function call (example in Chrome or Edge)\n          defaultProxy = defaultProxy + 1;\n        }\n\n        return error.stack.split('\\n')[defaultProxy + (config.proxiedSteps || 0)];\n      } catch (e) {\n        return null;\n      }\n    }\n  }\n  /**\r\n   * Get position of caller without using sourceMaps\r\n   * @param stackLine\r\n   * @returns\r\n   */\n\n\n  getLocalPosition(stackLine) {\n    // strip base path, then parse filename, line, and column, stackline looks like this :\n    // Firefox\n    // handleLog@http://localhost:4200/main.js:1158:29\n    // Chrome and Edge\n    // at AppComponent.handleLog (app.component.ts:38)\n    const positionStartIndex = stackLine.lastIndexOf('\\/');\n    let positionEndIndex = stackLine.indexOf(')');\n\n    if (positionEndIndex < 0) {\n      positionEndIndex = undefined;\n    }\n\n    const position = stackLine.substring(positionStartIndex + 1, positionEndIndex);\n    const dataArray = position.split(':');\n\n    if (dataArray.length === 3) {\n      return {\n        fileName: dataArray[0],\n        lineNumber: +dataArray[1],\n        columnNumber: +dataArray[2]\n      };\n    }\n\n    return {\n      fileName: 'unknown',\n      lineNumber: 0,\n      columnNumber: 0\n    };\n  }\n\n  getTranspileLocation(stackLine) {\n    // Example stackLine:\n    // Firefox : getStackLine@http://localhost:4200/main.js:358:23\n    // Chrome and Edge : at Function.getStackLine (ngx-logger.js:329)\n    let locationStartIndex = stackLine.indexOf('(');\n\n    if (locationStartIndex < 0) {\n      locationStartIndex = stackLine.lastIndexOf('@');\n\n      if (locationStartIndex < 0) {\n        locationStartIndex = stackLine.lastIndexOf(' ');\n      }\n    }\n\n    let locationEndIndex = stackLine.indexOf(')');\n\n    if (locationEndIndex < 0) {\n      locationEndIndex = undefined;\n    }\n\n    return stackLine.substring(locationStartIndex + 1, locationEndIndex);\n  }\n  /**\r\n   * Gets the URL of the sourcemap (the URL can be relative or absolute, it is browser dependant)\r\n   * @param stackLine\r\n   * @returns\r\n   */\n\n\n  getSourceMapLocation(stackLine) {\n    const file = this.getTranspileLocation(stackLine);\n    const mapFullPath = file.substring(0, file.lastIndexOf(':'));\n    return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';\n  }\n\n  getMapping(sourceMap, position) {\n    // => ';' indicates end of a line\n    // => ',' separates mappings in a line\n    // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]\n    let sourceFileIndex = 0,\n        // second field\n    sourceCodeLine = 0,\n        // third field\n    sourceCodeColumn = 0; // fourth field\n\n    const lines = sourceMap.mappings.split(';');\n\n    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\n      // reset column position to 0 after each line\n      let generatedCodeColumn = 0; // decode sections in line\n\n      const columns = lines[lineIndex].split(',');\n\n      for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {\n        const decodedSection = vlq.decode(columns[columnIndex]);\n\n        if (decodedSection.length >= 4) {\n          // update relative positions\n          generatedCodeColumn += decodedSection[0];\n          sourceFileIndex += decodedSection[1];\n          sourceCodeLine += decodedSection[2];\n          sourceCodeColumn += decodedSection[3];\n        } // check if matching map\n\n\n        if (lineIndex === position.lineNumber) {\n          if (generatedCodeColumn === position.columnNumber) {\n            // matching column and line found\n            return {\n              fileName: sourceMap.sources[sourceFileIndex],\n              lineNumber: sourceCodeLine,\n              columnNumber: sourceCodeColumn\n            };\n          } else if (columnIndex + 1 === columns.length) {\n            // matching column not found, but line is correct\n            return {\n              fileName: sourceMap.sources[sourceFileIndex],\n              lineNumber: sourceCodeLine,\n              columnNumber: 0\n            };\n          }\n        }\n      }\n    } // failed if reached\n\n\n    return {\n      fileName: 'unknown',\n      lineNumber: 0,\n      columnNumber: 0\n    };\n  }\n  /**\r\n   * does the http get request to get the source map\r\n   * @param sourceMapLocation\r\n   * @param distPosition\r\n   */\n\n\n  getSourceMap(sourceMapLocation, distPosition) {\n    const req = new HttpRequest('GET', sourceMapLocation);\n    const distPositionKey = `${distPosition.fileName}:${distPosition.lineNumber}:${distPosition.columnNumber}`; // if the specific log position is already in cache return it\n\n    if (this.logPositionCache.has(distPositionKey)) {\n      return this.logPositionCache.get(distPositionKey);\n    } // otherwise check if the source map is already cached for given source map location\n\n\n    if (!this.sourceMapCache.has(sourceMapLocation)) {\n      if (!this.httpBackend) {\n        console.error('NGXLogger : Can\\'t get sourcemap because HttpBackend is not provided. You need to import HttpClientModule');\n        this.sourceMapCache.set(sourceMapLocation, of(null));\n      } else {\n        // obtain the source map if not cached\n        this.sourceMapCache.set(sourceMapLocation, this.httpBackend.handle(req).pipe(filter(e => e instanceof HttpResponse), map(httpResponse => httpResponse.body), retry(3), shareReplay(1)));\n      }\n    } // at this point the source map is cached, use it to get specific log position mapping\n\n\n    const logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(map(sourceMap => {\n      // sourceMap can be null if HttpBackend is not provided for example\n      if (!sourceMap) {\n        return distPosition;\n      } // map generated position to source position\n\n\n      return this.getMapping(sourceMap, distPosition);\n    }), catchError(() => of(distPosition)), shareReplay(1)); // store specific log position in cache for given dest position and return it\n\n    this.logPositionCache.set(distPositionKey, logPosition$);\n    return logPosition$;\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerMapperService.ɵfac = function NGXLoggerMapperService_Factory(t) {\n  return new (t || NGXLoggerMapperService)(i0.ɵɵinject(i1.HttpBackend, 8));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerMapperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerMapperService,\n  factory: NGXLoggerMapperService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerMapperService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1.HttpBackend,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n/**\r\n * Injection token of logger metadata service\r\n */\n\n\nconst TOKEN_LOGGER_METADATA_SERVICE = 'TOKEN_LOGGER_METADATA_SERVICE';\n\nclass NGXLoggerMetadataService {\n  constructor(datePipe) {\n    this.datePipe = datePipe;\n  }\n\n  computeTimestamp(config) {\n    const defaultTimestamp = () => new Date().toISOString();\n\n    if (config.timestampFormat) {\n      if (!this.datePipe) {\n        console.error('NGXLogger : Can\\'t use timeStampFormat because DatePipe is not provided. You need to provide DatePipe');\n        return defaultTimestamp();\n      } else {\n        return this.datePipe.transform(new Date(), config.timestampFormat);\n      }\n    }\n\n    return defaultTimestamp();\n  }\n\n  getMetadata(level, config, message, additional) {\n    const metadata = {\n      level: level,\n      additional: additional\n    }; // The user can send a function\n    // This is useful in order to compute string concatenation only when the log will actually be written\n\n    if (message && typeof message === 'function') {\n      metadata.message = message();\n    } else {\n      metadata.message = message;\n    }\n\n    metadata.timestamp = this.computeTimestamp(config);\n    return metadata;\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerMetadataService.ɵfac = function NGXLoggerMetadataService_Factory(t) {\n  return new (t || NGXLoggerMetadataService)(i0.ɵɵinject(i1$1.DatePipe, 8));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerMetadataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerMetadataService,\n  factory: NGXLoggerMetadataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerMetadataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1$1.DatePipe,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})(); // I kept this class alive only to avoid a breaking change with the old version\n// This class does not implement anything so it is useless and the interface is enough\n\n/**\r\n * @deprecated this class does not implement anything thus being useless, you should rather implements @see INGXLoggerMonitor\r\n */\n\n\nclass NGXLoggerMonitor {}\n/**\r\n * Injection token of logger metadata service\r\n */\n\n\nconst TOKEN_LOGGER_RULES_SERVICE = 'TOKEN_LOGGER_RULES_SERVICE';\n\nclass NGXLoggerRulesService {\n  shouldCallWriter(level, config, message, additional) {\n    return !config.disableConsoleLogging && level >= config.level;\n  }\n\n  shouldCallServer(level, config, message, additional) {\n    return !!config.serverLoggingUrl && level >= config.serverLogLevel;\n  }\n\n  shouldCallMonitor(level, config, message, additional) {\n    // The default behavior is to call the monitor only if the writer or the server is called\n    return this.shouldCallWriter(level, config, message, additional) || this.shouldCallServer(level, config, message, additional);\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerRulesService.ɵfac = function NGXLoggerRulesService_Factory(t) {\n  return new (t || NGXLoggerRulesService)();\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerRulesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerRulesService,\n  factory: NGXLoggerRulesService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerRulesService, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\r\n * Injection token of logger server service\r\n */\n\n\nconst TOKEN_LOGGER_SERVER_SERVICE = 'TOKEN_LOGGER_SERVER_SERVICE';\n\nclass NGXLoggerServerService {\n  constructor(httpBackend) {\n    this.httpBackend = httpBackend;\n  }\n  /**\r\n   * Transforms an error object into a readable string (taking only the stack)\r\n   * This is needed because JSON.stringify would return \"{}\"\r\n   * @param err the error object\r\n   * @returns The stack of the error\r\n   */\n\n\n  secureErrorObject(err) {\n    return err === null || err === void 0 ? void 0 : err.stack;\n  }\n  /**\r\n   * Transforms the additional parameters to avoid any json error when sending the data to the server\r\n   * Basically it just replaces unstringifiable object to a string mentioning an error\r\n   * @param additional The additional data to be sent\r\n   * @returns The additional data secured\r\n   */\n\n\n  secureAdditionalParameters(additional) {\n    if (additional === null || additional === undefined) {\n      return null;\n    }\n\n    return additional.map((next, idx) => {\n      try {\n        if (next instanceof Error) {\n          return this.secureErrorObject(next);\n        } // We just want to make sure the JSON can be parsed, we do not want to actually change the type\n\n\n        if (typeof next === 'object') {\n          JSON.stringify(next);\n        }\n\n        return next;\n      } catch (e) {\n        return `The additional[${idx}] value could not be parsed using JSON.stringify().`;\n      }\n    });\n  }\n  /**\r\n   * Transforms the message so that it can be sent to the server\r\n   * @param message the message to be sent\r\n   * @returns the message secured\r\n   */\n\n\n  secureMessage(message) {\n    try {\n      if (message instanceof Error) {\n        return this.secureErrorObject(message);\n      }\n\n      if (typeof message !== 'string') {\n        message = JSON.stringify(message, null, 2);\n      }\n    } catch (e) {\n      message = 'The provided \"message\" value could not be parsed with JSON.stringify().';\n    }\n\n    return message;\n  }\n  /**\r\n   * Edits HttpRequest object before sending request to server\r\n   * @param httpRequest default request object\r\n   * @returns altered httprequest\r\n   */\n\n\n  alterHttpRequest(httpRequest) {\n    return httpRequest;\n  }\n  /**\r\n   * Sends request to server\r\n   * @param url\r\n   * @param logContent\r\n   * @param options\r\n   * @returns\r\n   */\n\n\n  logOnServer(url, logContent, options) {\n    if (!this.httpBackend) {\n      console.error('NGXLogger : Can\\'t log on server because HttpBackend is not provided. You need to import HttpClientModule');\n      return of(null);\n    } // HttpBackend skips all HttpInterceptors\n    // They may log errors using this service causing circular calls\n\n\n    let defaultRequest = new HttpRequest('POST', url, logContent, options || {});\n    let finalRequest = of(defaultRequest);\n    const alteredRequest = this.alterHttpRequest(defaultRequest);\n\n    if (isObservable(alteredRequest)) {\n      finalRequest = alteredRequest;\n    } else if (alteredRequest) {\n      finalRequest = of(alteredRequest);\n    } else {\n      console.warn('NGXLogger : alterHttpRequest returned an invalid request. Using default one instead');\n    }\n\n    return finalRequest.pipe(concatMap(req => {\n      if (!req) {\n        console.warn('NGXLogger : alterHttpRequest returned an invalid request (observable). Using default one instead');\n        return this.httpBackend.handle(defaultRequest);\n      }\n\n      return this.httpBackend.handle(req);\n    }), filter(e => e instanceof HttpResponse), map(httpResponse => httpResponse.body));\n  }\n  /**\r\n   * Customise the data sent to the API\r\n   * @param metadata the data provided by NGXLogger\r\n   * @returns the data that will be sent to the API in the body\r\n   */\n\n\n  customiseRequestBody(metadata) {\n    // In our API the body is not customised\n    return metadata;\n  }\n\n  sendToServer(metadata, config) {\n    // Copying metadata locally because we don't want to change the object for the caller\n    const localMetadata = Object.assign({}, metadata);\n    localMetadata.additional = this.secureAdditionalParameters(localMetadata.additional);\n    localMetadata.message = this.secureMessage(localMetadata.message); // Allow users to customise the data sent to the API\n\n    const requestBody = this.customiseRequestBody(localMetadata);\n    const headers = config.customHttpHeaders || new HttpHeaders();\n\n    if (!headers.has('Content-Type')) {\n      headers.set('Content-Type', 'application/json');\n    }\n\n    this.logOnServer(config.serverLoggingUrl, requestBody, {\n      headers,\n      params: config.customHttpParams || new HttpParams(),\n      responseType: config.httpResponseType || 'json',\n      withCredentials: config.withCredentials || false\n    }).pipe(catchError(err => {\n      // Do not use NGXLogger here because this could cause an infinite loop \n      console.error('NGXLogger: Failed to log on server', err);\n      return throwError(err);\n    })).subscribe();\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerServerService.ɵfac = function NGXLoggerServerService_Factory(t) {\n  return new (t || NGXLoggerServerService)(i0.ɵɵinject(i1.HttpBackend, 8));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerServerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerServerService,\n  factory: NGXLoggerServerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerServerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1.HttpBackend,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n/**\r\n * Injection token of logger writer service\r\n */\n\n\nconst TOKEN_LOGGER_WRITER_SERVICE = 'TOKEN_LOGGER_WRITER_SERVICE';\nvar NgxLoggerLevel;\n\n(function (NgxLoggerLevel) {\n  NgxLoggerLevel[NgxLoggerLevel[\"TRACE\"] = 0] = \"TRACE\";\n  NgxLoggerLevel[NgxLoggerLevel[\"DEBUG\"] = 1] = \"DEBUG\";\n  NgxLoggerLevel[NgxLoggerLevel[\"INFO\"] = 2] = \"INFO\";\n  NgxLoggerLevel[NgxLoggerLevel[\"LOG\"] = 3] = \"LOG\";\n  NgxLoggerLevel[NgxLoggerLevel[\"WARN\"] = 4] = \"WARN\";\n  NgxLoggerLevel[NgxLoggerLevel[\"ERROR\"] = 5] = \"ERROR\";\n  NgxLoggerLevel[NgxLoggerLevel[\"FATAL\"] = 6] = \"FATAL\";\n  NgxLoggerLevel[NgxLoggerLevel[\"OFF\"] = 7] = \"OFF\";\n})(NgxLoggerLevel || (NgxLoggerLevel = {}));\n\nconst DEFAULT_COLOR_SCHEME = ['purple', 'teal', 'gray', 'gray', 'red', 'red', 'red'];\n\nclass NGXLoggerWriterService {\n  constructor(platformId) {\n    this.platformId = platformId;\n    /** List of functions called when preparing meta string */\n\n    this.prepareMetaStringFuncs = [this.getTimestampToWrite, this.getLevelToWrite, this.getFileDetailsToWrite, this.getContextToWrite];\n    this.isIE = isPlatformBrowser(platformId) && navigator && navigator.userAgent && !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\\//) || navigator.userAgent.match(/Edge\\//));\n    this.logFunc = this.isIE ? this.logIE.bind(this) : this.logModern.bind(this);\n  }\n\n  getTimestampToWrite(metadata, config) {\n    return metadata.timestamp;\n  }\n\n  getLevelToWrite(metadata, config) {\n    return NgxLoggerLevel[metadata.level];\n  }\n\n  getFileDetailsToWrite(metadata, config) {\n    return config.disableFileDetails === true ? '' : `[${metadata.fileName}:${metadata.lineNumber}:${metadata.columnNumber}]`;\n  }\n\n  getContextToWrite(metadata, config) {\n    return config.context ? `{${config.context}}` : '';\n  }\n  /** Generate a \"meta\" string that is displayed before the content sent to the log function */\n\n\n  prepareMetaString(metadata, config) {\n    let metaString = '';\n    this.prepareMetaStringFuncs.forEach(prepareMetaStringFunc => {\n      const metaItem = prepareMetaStringFunc(metadata, config);\n\n      if (metaItem) {\n        metaString = metaString + ' ' + metaItem;\n      }\n    });\n    return metaString.trim();\n  }\n  /** Get the color to use when writing to console */\n\n\n  getColor(metadata, config) {\n    var _a;\n\n    const configColorScheme = (_a = config.colorScheme) !== null && _a !== void 0 ? _a : DEFAULT_COLOR_SCHEME; // this is needed to avoid a build error\n\n    if (metadata.level === NgxLoggerLevel.OFF) {\n      return undefined;\n    }\n\n    return configColorScheme[metadata.level];\n  }\n  /** Log to the console specifically for IE */\n\n\n  logIE(metadata, config, metaString) {\n    // Coloring doesn't work in IE\n    // make sure additional isn't null or undefined so that ...additional doesn't error\n    const additional = metadata.additional || [];\n\n    switch (metadata.level) {\n      case NgxLoggerLevel.WARN:\n        console.warn(`${metaString} `, metadata.message, ...additional);\n        break;\n\n      case NgxLoggerLevel.ERROR:\n      case NgxLoggerLevel.FATAL:\n        console.error(`${metaString} `, metadata.message, ...additional);\n        break;\n\n      case NgxLoggerLevel.INFO:\n        console.info(`${metaString} `, metadata.message, ...additional);\n        break;\n\n      default:\n        console.log(`${metaString} `, metadata.message, ...additional);\n    }\n  }\n  /** Log to the console */\n\n\n  logModern(metadata, config, metaString) {\n    const color = this.getColor(metadata, config); // make sure additional isn't null or undefined so that ...additional doesn't error\n\n    const additional = metadata.additional || [];\n\n    switch (metadata.level) {\n      case NgxLoggerLevel.WARN:\n        console.warn(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n\n      case NgxLoggerLevel.ERROR:\n      case NgxLoggerLevel.FATAL:\n        console.error(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n\n      case NgxLoggerLevel.INFO:\n        console.info(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n      //  Disabling console.trace since the stack trace is not helpful. it is showing the stack trace of\n      // the console.trace statement\n      // case NgxLoggerLevel.TRACE:\n      //   console.trace(`%c${metaString}`, `color:${color}`, message, ...additional);\n      //   break;\n\n      case NgxLoggerLevel.DEBUG:\n        console.debug(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n\n      default:\n        console.log(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n    }\n  }\n  /** Write the content sent to the log function to the console */\n\n\n  writeMessage(metadata, config) {\n    const metaString = this.prepareMetaString(metadata, config);\n    this.logFunc(metadata, config, metaString);\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerWriterService.ɵfac = function NGXLoggerWriterService_Factory(t) {\n  return new (t || NGXLoggerWriterService)(i0.ɵɵinject(PLATFORM_ID));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerWriterService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerWriterService,\n  factory: NGXLoggerWriterService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerWriterService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n\nclass NGXLogger {\n  constructor(config, configEngineFactory, metadataService, ruleService, mapperService, writerService, serverService) {\n    this.metadataService = metadataService;\n    this.ruleService = ruleService;\n    this.mapperService = mapperService;\n    this.writerService = writerService;\n    this.serverService = serverService;\n    this.configEngine = configEngineFactory.provideConfigEngine(config);\n  }\n  /** Get a readonly access to the level configured for the NGXLogger */\n\n\n  get level() {\n    return this.configEngine.level;\n  }\n  /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\n\n\n  get serverLogLevel() {\n    return this.configEngine.serverLogLevel;\n  }\n\n  trace(message, ...additional) {\n    this._log(NgxLoggerLevel.TRACE, message, additional);\n  }\n\n  debug(message, ...additional) {\n    this._log(NgxLoggerLevel.DEBUG, message, additional);\n  }\n\n  info(message, ...additional) {\n    this._log(NgxLoggerLevel.INFO, message, additional);\n  }\n\n  log(message, ...additional) {\n    this._log(NgxLoggerLevel.LOG, message, additional);\n  }\n\n  warn(message, ...additional) {\n    this._log(NgxLoggerLevel.WARN, message, additional);\n  }\n\n  error(message, ...additional) {\n    this._log(NgxLoggerLevel.ERROR, message, additional);\n  }\n\n  fatal(message, ...additional) {\n    this._log(NgxLoggerLevel.FATAL, message, additional);\n  }\n  /** @deprecated customHttpHeaders is now part of the config, this should be updated via @see updateConfig */\n\n\n  setCustomHttpHeaders(headers) {\n    const config = this.getConfigSnapshot();\n    config.customHttpHeaders = headers;\n    this.updateConfig(config);\n  }\n  /** @deprecated customHttpParams is now part of the config, this should be updated via @see updateConfig */\n\n\n  setCustomParams(params) {\n    const config = this.getConfigSnapshot();\n    config.customHttpParams = params;\n    this.updateConfig(config);\n  }\n  /** @deprecated withCredentials is now part of the config, this should be updated via @see updateConfig */\n\n\n  setWithCredentialsOptionValue(withCredentials) {\n    const config = this.getConfigSnapshot();\n    config.withCredentials = withCredentials;\n    this.updateConfig(config);\n  }\n  /**\r\n   * Register a INGXLoggerMonitor that will be trigger when a log is either written or sent to server\r\n   *\r\n   * There is only one monitor, registering one will overwrite the last one if there was one\r\n   * @param monitor\r\n   */\n\n\n  registerMonitor(monitor) {\n    this._loggerMonitor = monitor;\n  }\n  /** Set config of logger\r\n   *\r\n   * Warning : This overwrites all the config, if you want to update only one property, you should use @see getConfigSnapshot before\r\n   */\n\n\n  updateConfig(config) {\n    this.configEngine.updateConfig(config);\n  }\n\n  partialUpdateConfig(partialConfig) {\n    this.configEngine.partialUpdateConfig(partialConfig);\n  }\n  /** Get config of logger */\n\n\n  getConfigSnapshot() {\n    return this.configEngine.getConfig();\n  }\n\n  _log(level, message, additional = []) {\n    const config = this.configEngine.getConfig();\n    const shouldCallWriter = this.ruleService.shouldCallWriter(level, config, message, additional);\n    const shouldCallServer = this.ruleService.shouldCallServer(level, config, message, additional);\n    const shouldCallMonitor = this.ruleService.shouldCallMonitor(level, config, message, additional);\n\n    if (!shouldCallWriter && !shouldCallServer && !shouldCallMonitor) {\n      // If nothing is to be called we return\n      return;\n    }\n\n    const metadata = this.metadataService.getMetadata(level, config, message, additional);\n    this.mapperService.getLogPosition(config, metadata).pipe(take(1)).subscribe(logPosition => {\n      if (logPosition) {\n        metadata.fileName = logPosition.fileName;\n        metadata.lineNumber = logPosition.lineNumber;\n        metadata.columnNumber = logPosition.columnNumber;\n      }\n\n      if (shouldCallMonitor && this._loggerMonitor) {\n        this._loggerMonitor.onLog(metadata, config);\n      }\n\n      if (shouldCallWriter) {\n        this.writerService.writeMessage(metadata, config);\n      }\n\n      if (shouldCallServer) {\n        this.serverService.sendToServer(metadata, config);\n      }\n    });\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLogger.ɵfac = function NGXLogger_Factory(t) {\n  return new (t || NGXLogger)(i0.ɵɵinject(TOKEN_LOGGER_CONFIG), i0.ɵɵinject(TOKEN_LOGGER_CONFIG_ENGINE_FACTORY), i0.ɵɵinject(TOKEN_LOGGER_METADATA_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_RULES_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_MAPPER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_WRITER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_SERVER_SERVICE));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLogger.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLogger,\n  factory: NGXLogger.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLogger, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_CONFIG]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_CONFIG_ENGINE_FACTORY]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_METADATA_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_RULES_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_MAPPER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_WRITER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_SERVER_SERVICE]\n      }]\n    }];\n  }, null);\n})();\n/**\r\n * CustomNGXLoggerService is designed to allow users to get a new instance of a logger\r\n */\n\n\nclass CustomNGXLoggerService {\n  constructor(logger, configEngineFactory, metadataService, ruleService, mapperService, writerService, serverService) {\n    this.logger = logger;\n    this.configEngineFactory = configEngineFactory;\n    this.metadataService = metadataService;\n    this.ruleService = ruleService;\n    this.mapperService = mapperService;\n    this.writerService = writerService;\n    this.serverService = serverService;\n  }\n  /**\r\n   * Create an instance of a logger\r\n   * @deprecated this function does not have all the features, @see getNewInstance for every params available\r\n   * @param config\r\n   * @param serverService\r\n   * @param logMonitor\r\n   * @param mapperService\r\n   * @returns\r\n   */\n\n\n  create(config, serverService, logMonitor, mapperService) {\n    return this.getNewInstance({\n      config,\n      serverService,\n      logMonitor,\n      mapperService\n    });\n  }\n  /**\r\n   * Get a new instance of NGXLogger\r\n   * @param params list of optional params to use when creating an instance of NGXLogger\r\n   * @returns the new instance of NGXLogger\r\n   */\n\n\n  getNewInstance(params) {\n    var _a, _b, _c, _d, _e, _f, _g;\n\n    const logger = new NGXLogger((_a = params === null || params === void 0 ? void 0 : params.config) !== null && _a !== void 0 ? _a : this.logger.getConfigSnapshot(), (_b = params === null || params === void 0 ? void 0 : params.configEngineFactory) !== null && _b !== void 0 ? _b : this.configEngineFactory, (_c = params === null || params === void 0 ? void 0 : params.metadataService) !== null && _c !== void 0 ? _c : this.metadataService, (_d = params === null || params === void 0 ? void 0 : params.ruleService) !== null && _d !== void 0 ? _d : this.ruleService, (_e = params === null || params === void 0 ? void 0 : params.mapperService) !== null && _e !== void 0 ? _e : this.mapperService, (_f = params === null || params === void 0 ? void 0 : params.writerService) !== null && _f !== void 0 ? _f : this.writerService, (_g = params === null || params === void 0 ? void 0 : params.serverService) !== null && _g !== void 0 ? _g : this.serverService);\n\n    if (params === null || params === void 0 ? void 0 : params.partialConfig) {\n      logger.partialUpdateConfig(params.partialConfig);\n    }\n\n    if (params === null || params === void 0 ? void 0 : params.logMonitor) {\n      logger.registerMonitor(params.logMonitor);\n    }\n\n    return logger;\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nCustomNGXLoggerService.ɵfac = function CustomNGXLoggerService_Factory(t) {\n  return new (t || CustomNGXLoggerService)(i0.ɵɵinject(NGXLogger), i0.ɵɵinject(TOKEN_LOGGER_CONFIG_ENGINE_FACTORY), i0.ɵɵinject(TOKEN_LOGGER_METADATA_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_RULES_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_MAPPER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_WRITER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_SERVER_SERVICE));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nCustomNGXLoggerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CustomNGXLoggerService,\n  factory: CustomNGXLoggerService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CustomNGXLoggerService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: NGXLogger\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_CONFIG_ENGINE_FACTORY]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_METADATA_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_RULES_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_MAPPER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_WRITER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_SERVER_SERVICE]\n      }]\n    }];\n  }, null);\n})();\n\nclass LoggerModule {\n  static forRoot(config, customProvider) {\n    if (!customProvider) {\n      customProvider = {};\n    } // default config provider\n\n\n    if (!customProvider.configProvider) {\n      customProvider.configProvider = {\n        provide: TOKEN_LOGGER_CONFIG,\n        useValue: config || {}\n      };\n    } else {\n      // if the user provided its own config, we just make sure the injection token is correct\n      if (customProvider.configProvider.provide !== TOKEN_LOGGER_CONFIG) {\n        throw new Error(`Wrong injection token for configProvider, it should be ${TOKEN_LOGGER_CONFIG} and you used ${customProvider.configProvider.provide}`);\n      }\n    } // default configEngine provider\n\n\n    if (!customProvider.configEngineFactoryProvider) {\n      customProvider.configEngineFactoryProvider = {\n        provide: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY,\n        useClass: NGXLoggerConfigEngineFactory\n      };\n    } else {\n      // if the user provided its own configEngineFactory, we just make sure the injection token is correct\n      if (customProvider.configEngineFactoryProvider.provide !== TOKEN_LOGGER_CONFIG_ENGINE_FACTORY) {\n        throw new Error(`Wrong injection token for configEngineFactoryProvider, it should be '${TOKEN_LOGGER_CONFIG_ENGINE_FACTORY}' and you used '${customProvider.configEngineFactoryProvider.provide}'`);\n      }\n    } // default metadata provider\n\n\n    if (!customProvider.metadataProvider) {\n      customProvider.metadataProvider = {\n        provide: TOKEN_LOGGER_METADATA_SERVICE,\n        useClass: NGXLoggerMetadataService\n      };\n    } else {\n      // if the user provided its own metadataService, we just make sure the injection token is correct\n      if (customProvider.metadataProvider.provide !== TOKEN_LOGGER_METADATA_SERVICE) {\n        throw new Error(`Wrong injection token for metadataProvider, it should be '${TOKEN_LOGGER_METADATA_SERVICE}' and you used '${customProvider.metadataProvider.provide}'`);\n      }\n    } // default rule provider\n\n\n    if (!customProvider.ruleProvider) {\n      customProvider.ruleProvider = {\n        provide: TOKEN_LOGGER_RULES_SERVICE,\n        useClass: NGXLoggerRulesService\n      };\n    } else {\n      // if the user provided its own ruleService, we just make sure the injection token is correct\n      if (customProvider.ruleProvider.provide !== TOKEN_LOGGER_RULES_SERVICE) {\n        throw new Error(`Wrong injection token for ruleProvider, it should be '${TOKEN_LOGGER_RULES_SERVICE}' and you used '${customProvider.ruleProvider.provide}'`);\n      }\n    } // default mapper provider\n\n\n    if (!customProvider.mapperProvider) {\n      customProvider.mapperProvider = {\n        provide: TOKEN_LOGGER_MAPPER_SERVICE,\n        useClass: NGXLoggerMapperService\n      };\n    } else {\n      // if the user provided its own mapperService, we just make sure the injection token is correct\n      if (customProvider.mapperProvider.provide !== TOKEN_LOGGER_MAPPER_SERVICE) {\n        throw new Error(`Wrong injection token for mapperProvider, it should be '${TOKEN_LOGGER_MAPPER_SERVICE}' and you used '${customProvider.mapperProvider.provide}'`);\n      }\n    } // default writer provider\n\n\n    if (!customProvider.writerProvider) {\n      customProvider.writerProvider = {\n        provide: TOKEN_LOGGER_WRITER_SERVICE,\n        useClass: NGXLoggerWriterService\n      };\n    } else {\n      // if the user provided its own writerService, we just make sure the injection token is correct\n      if (customProvider.writerProvider.provide !== TOKEN_LOGGER_WRITER_SERVICE) {\n        throw new Error(`Wrong injection token for writerProvider, it should be '${TOKEN_LOGGER_WRITER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\n      }\n    } // default server provider\n\n\n    if (!customProvider.serverProvider) {\n      customProvider.serverProvider = {\n        provide: TOKEN_LOGGER_SERVER_SERVICE,\n        useClass: NGXLoggerServerService\n      };\n    } else {\n      // if the user provided its own serverService, we just make sure the injection token is correct\n      if (customProvider.serverProvider.provide !== TOKEN_LOGGER_SERVER_SERVICE) {\n        throw new Error(`Wrong injection token for serverProvider, it should be '${TOKEN_LOGGER_SERVER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\n      }\n    }\n\n    return {\n      ngModule: LoggerModule,\n      providers: [NGXLogger, customProvider.configProvider, customProvider.configEngineFactoryProvider, customProvider.metadataProvider, customProvider.ruleProvider, customProvider.mapperProvider, customProvider.writerProvider, customProvider.serverProvider, CustomNGXLoggerService]\n    };\n  }\n\n  static forChild() {\n    // todo : this forChild is useless for now because nothing is different from forRoot.\n    // This should be implemented so that user can change the providers in the forChild\n    return {\n      ngModule: LoggerModule\n    };\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nLoggerModule.ɵfac = function LoggerModule_Factory(t) {\n  return new (t || LoggerModule)();\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nLoggerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: LoggerModule\n});\n/** @nocollapse */\n\n/** @nocollapse */\n\nLoggerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoggerModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule]\n    }]\n  }], null, null);\n})();\n/*\r\n * Public API Surface of ngx-logger\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { CustomNGXLoggerService, DEFAULT_COLOR_SCHEME, LoggerModule, NGXLogger, NGXLoggerConfigEngine, NGXLoggerConfigEngineFactory, NGXLoggerMapperService, NGXLoggerMetadataService, NGXLoggerMonitor, NGXLoggerRulesService, NGXLoggerServerService, NGXLoggerWriterService, NgxLoggerLevel, TOKEN_LOGGER_CONFIG, TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, TOKEN_LOGGER_MAPPER_SERVICE, TOKEN_LOGGER_METADATA_SERVICE, TOKEN_LOGGER_RULES_SERVICE, TOKEN_LOGGER_SERVER_SERVICE, TOKEN_LOGGER_WRITER_SERVICE };","map":{"version":3,"sources":["D:/my-work/Soft-chaos/node_modules/ngx-logger/fesm2015/ngx-logger.mjs"],"names":["i1","HttpRequest","HttpResponse","HttpHeaders","HttpParams","i0","Injectable","Optional","PLATFORM_ID","Inject","NgModule","of","isObservable","throwError","filter","map","retry","shareReplay","catchError","concatMap","take","vlq","i1$1","isPlatformBrowser","CommonModule","TOKEN_LOGGER_CONFIG","NGXLoggerConfigEngine","constructor","config","_clone","level","serverLogLevel","updateConfig","partialUpdateConfig","partialConfig","Object","keys","forEach","configParamKey","getConfig","object","cloneConfig","key","TOKEN_LOGGER_CONFIG_ENGINE_FACTORY","NGXLoggerConfigEngineFactory","provideConfigEngine","TOKEN_LOGGER_MAPPER_SERVICE","NGXLoggerMapperService","httpBackend","sourceMapCache","Map","logPositionCache","getLogPosition","metadata","stackLine","getStackLine","fileName","lineNumber","columnNumber","logPosition","getLocalPosition","enableSourceMaps","sourceMapLocation","getSourceMapLocation","getSourceMap","error","Error","e","defaultProxy","firstStackLine","stack","split","includes","proxiedSteps","positionStartIndex","lastIndexOf","positionEndIndex","indexOf","undefined","position","substring","dataArray","length","getTranspileLocation","locationStartIndex","locationEndIndex","file","mapFullPath","getMapping","sourceMap","sourceFileIndex","sourceCodeLine","sourceCodeColumn","lines","mappings","lineIndex","generatedCodeColumn","columns","columnIndex","decodedSection","decode","sources","distPosition","req","distPositionKey","has","get","console","set","handle","pipe","httpResponse","body","logPosition$","ɵfac","HttpBackend","ɵprov","type","decorators","TOKEN_LOGGER_METADATA_SERVICE","NGXLoggerMetadataService","datePipe","computeTimestamp","defaultTimestamp","Date","toISOString","timestampFormat","transform","getMetadata","message","additional","timestamp","DatePipe","NGXLoggerMonitor","TOKEN_LOGGER_RULES_SERVICE","NGXLoggerRulesService","shouldCallWriter","disableConsoleLogging","shouldCallServer","serverLoggingUrl","shouldCallMonitor","TOKEN_LOGGER_SERVER_SERVICE","NGXLoggerServerService","secureErrorObject","err","secureAdditionalParameters","next","idx","JSON","stringify","secureMessage","alterHttpRequest","httpRequest","logOnServer","url","logContent","options","defaultRequest","finalRequest","alteredRequest","warn","customiseRequestBody","sendToServer","localMetadata","assign","requestBody","headers","customHttpHeaders","params","customHttpParams","responseType","httpResponseType","withCredentials","subscribe","TOKEN_LOGGER_WRITER_SERVICE","NgxLoggerLevel","DEFAULT_COLOR_SCHEME","NGXLoggerWriterService","platformId","prepareMetaStringFuncs","getTimestampToWrite","getLevelToWrite","getFileDetailsToWrite","getContextToWrite","isIE","navigator","userAgent","match","logFunc","logIE","bind","logModern","disableFileDetails","context","prepareMetaString","metaString","prepareMetaStringFunc","metaItem","trim","getColor","_a","configColorScheme","colorScheme","OFF","WARN","ERROR","FATAL","INFO","info","log","color","DEBUG","debug","writeMessage","args","NGXLogger","configEngineFactory","metadataService","ruleService","mapperService","writerService","serverService","configEngine","trace","_log","TRACE","LOG","fatal","setCustomHttpHeaders","getConfigSnapshot","setCustomParams","setWithCredentialsOptionValue","registerMonitor","monitor","_loggerMonitor","onLog","providedIn","CustomNGXLoggerService","logger","create","logMonitor","getNewInstance","_b","_c","_d","_e","_f","_g","LoggerModule","forRoot","customProvider","configProvider","provide","useValue","configEngineFactoryProvider","useClass","metadataProvider","ruleProvider","mapperProvider","writerProvider","serverProvider","ngModule","providers","forChild","ɵmod","ɵinj","imports"],"mappings":"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","sourcesContent":["import * as i1 from '@angular/common/http';\nimport { HttpRequest, HttpResponse, HttpHeaders, HttpParams } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Optional, PLATFORM_ID, Inject, NgModule } from '@angular/core';\nimport { of, isObservable, throwError } from 'rxjs';\nimport { filter, map, retry, shareReplay, catchError, concatMap, take } from 'rxjs/operators';\nimport * as vlq from 'vlq';\nimport * as i1$1 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\n\n/**\r\n * Injection token of logger config\r\n */\r\nconst TOKEN_LOGGER_CONFIG = 'TOKEN_LOGGER_CONFIG';\n\nclass NGXLoggerConfigEngine {\r\n    constructor(config) {\r\n        this.config = this._clone(config);\r\n    }\r\n    /** Get a readonly access to the level configured for the NGXLogger */\r\n    get level() {\r\n        return this.config.level;\r\n    }\r\n    /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\r\n    get serverLogLevel() {\r\n        return this.config.serverLogLevel;\r\n    }\r\n    updateConfig(config) {\r\n        this.config = this._clone(config);\r\n    }\r\n    /** Update the config partially\r\n     * This is useful if you want to update only one parameter of the config\r\n     */\r\n    partialUpdateConfig(partialConfig) {\r\n        // avoid any error if the config is incorrect\r\n        if (!partialConfig) {\r\n            return;\r\n        }\r\n        Object.keys(partialConfig).forEach(configParamKey => {\r\n            this.config[configParamKey] = partialConfig[configParamKey];\r\n        });\r\n    }\r\n    getConfig() {\r\n        return this._clone(this.config);\r\n    }\r\n    // TODO: This is a shallow clone, If the config ever becomes hierarchical we must make this a deep clone\r\n    _clone(object) {\r\n        const cloneConfig = { level: null };\r\n        Object.keys(object).forEach((key) => {\r\n            cloneConfig[key] = object[key];\r\n        });\r\n        return cloneConfig;\r\n    }\r\n}\n\n/**\r\n * Injection token of logger config engine factory\r\n */\r\nconst TOKEN_LOGGER_CONFIG_ENGINE_FACTORY = 'TOKEN_LOGGER_CONFIG_ENGINE_FACTORY';\n\nclass NGXLoggerConfigEngineFactory {\r\n    provideConfigEngine(config) {\r\n        return new NGXLoggerConfigEngine(config);\r\n    }\r\n}\n\n/**\r\n * Injection token of logger mapper service\r\n */\r\nconst TOKEN_LOGGER_MAPPER_SERVICE = 'TOKEN_LOGGER_MAPPER_SERVICE';\n\nclass NGXLoggerMapperService {\r\n    constructor(httpBackend) {\r\n        this.httpBackend = httpBackend;\r\n        /** cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map' */\r\n        this.sourceMapCache = new Map();\r\n        /** cache for specific log position, key is the dist position, ie 'main.js:339:21' */\r\n        this.logPositionCache = new Map();\r\n    }\r\n    /**\r\n     * Returns the log position of the caller\r\n     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the position\r\n     * @param config\r\n     * @param metadata\r\n     * @returns\r\n     */\r\n    getLogPosition(config, metadata) {\r\n        const stackLine = this.getStackLine(config);\r\n        // if we were not able to parse the stackLine, just return an empty Log Position\r\n        if (!stackLine) {\r\n            return of({ fileName: '', lineNumber: 0, columnNumber: 0 });\r\n        }\r\n        const logPosition = this.getLocalPosition(stackLine);\r\n        if (!config.enableSourceMaps) {\r\n            return of(logPosition);\r\n        }\r\n        const sourceMapLocation = this.getSourceMapLocation(stackLine);\r\n        return this.getSourceMap(sourceMapLocation, logPosition);\r\n    }\r\n    /**\r\n     * Get the stackline of the original caller\r\n     * @param config\r\n     * @returns null if stackline was not found\r\n     */\r\n    getStackLine(config) {\r\n        const error = new Error();\r\n        try {\r\n            // noinspection ExceptionCaughtLocallyJS\r\n            throw error;\r\n        }\r\n        catch (e) {\r\n            try {\r\n                // Here are different examples of stacktrace \r\n                // Firefox (last line is the user code, the 4 first are ours):\r\n                // getStackLine@http://localhost:4200/main.js:358:23\r\n                // getCallerDetails@http://localhost:4200/main.js:557:44\r\n                // _log@http://localhost:4200/main.js:830:28\r\n                // debug@http://localhost:4200/main.js:652:14\r\n                // handleLog@http://localhost:4200/main.js:1158:29\r\n                // Chrome and Edge (last line is the user code):\r\n                // Error\r\n                // at Function.getStackLine (ngx-logger.js:329)\r\n                // at NGXMapperService.getCallerDetails (ngx-logger.js:528)\r\n                // at NGXLogger._log (ngx-logger.js:801)\r\n                // at NGXLogger.info (ngx-logger.js:631)\r\n                // at AppComponent.handleLog (app.component.ts:38)\r\n                let defaultProxy = 4; // We make 4 functions call before getting here\r\n                const firstStackLine = error.stack.split('\\n')[0];\r\n                if (!firstStackLine.includes('.js:')) {\r\n                    // The stacktrace starts with no function call (example in Chrome or Edge)\r\n                    defaultProxy = defaultProxy + 1;\r\n                }\r\n                return error.stack.split('\\n')[(defaultProxy + (config.proxiedSteps || 0))];\r\n            }\r\n            catch (e) {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Get position of caller without using sourceMaps\r\n     * @param stackLine\r\n     * @returns\r\n     */\r\n    getLocalPosition(stackLine) {\r\n        // strip base path, then parse filename, line, and column, stackline looks like this :\r\n        // Firefox\r\n        // handleLog@http://localhost:4200/main.js:1158:29\r\n        // Chrome and Edge\r\n        // at AppComponent.handleLog (app.component.ts:38)\r\n        const positionStartIndex = stackLine.lastIndexOf('\\/');\r\n        let positionEndIndex = stackLine.indexOf(')');\r\n        if (positionEndIndex < 0) {\r\n            positionEndIndex = undefined;\r\n        }\r\n        const position = stackLine.substring(positionStartIndex + 1, positionEndIndex);\r\n        const dataArray = position.split(':');\r\n        if (dataArray.length === 3) {\r\n            return { fileName: dataArray[0], lineNumber: +dataArray[1], columnNumber: +dataArray[2] };\r\n        }\r\n        return { fileName: 'unknown', lineNumber: 0, columnNumber: 0 };\r\n    }\r\n    getTranspileLocation(stackLine) {\r\n        // Example stackLine:\r\n        // Firefox : getStackLine@http://localhost:4200/main.js:358:23\r\n        // Chrome and Edge : at Function.getStackLine (ngx-logger.js:329)\r\n        let locationStartIndex = stackLine.indexOf('(');\r\n        if (locationStartIndex < 0) {\r\n            locationStartIndex = stackLine.lastIndexOf('@');\r\n            if (locationStartIndex < 0) {\r\n                locationStartIndex = stackLine.lastIndexOf(' ');\r\n            }\r\n        }\r\n        let locationEndIndex = stackLine.indexOf(')');\r\n        if (locationEndIndex < 0) {\r\n            locationEndIndex = undefined;\r\n        }\r\n        return stackLine.substring(locationStartIndex + 1, locationEndIndex);\r\n    }\r\n    /**\r\n     * Gets the URL of the sourcemap (the URL can be relative or absolute, it is browser dependant)\r\n     * @param stackLine\r\n     * @returns\r\n     */\r\n    getSourceMapLocation(stackLine) {\r\n        const file = this.getTranspileLocation(stackLine);\r\n        const mapFullPath = file.substring(0, file.lastIndexOf(':'));\r\n        return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';\r\n    }\r\n    getMapping(sourceMap, position) {\r\n        // => ';' indicates end of a line\r\n        // => ',' separates mappings in a line\r\n        // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]\r\n        let sourceFileIndex = 0, // second field\r\n        sourceCodeLine = 0, // third field\r\n        sourceCodeColumn = 0; // fourth field\r\n        const lines = sourceMap.mappings.split(';');\r\n        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\r\n            // reset column position to 0 after each line\r\n            let generatedCodeColumn = 0;\r\n            // decode sections in line\r\n            const columns = lines[lineIndex].split(',');\r\n            for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {\r\n                const decodedSection = vlq.decode(columns[columnIndex]);\r\n                if (decodedSection.length >= 4) {\r\n                    // update relative positions\r\n                    generatedCodeColumn += decodedSection[0];\r\n                    sourceFileIndex += decodedSection[1];\r\n                    sourceCodeLine += decodedSection[2];\r\n                    sourceCodeColumn += decodedSection[3];\r\n                }\r\n                // check if matching map\r\n                if (lineIndex === position.lineNumber) {\r\n                    if (generatedCodeColumn === position.columnNumber) {\r\n                        // matching column and line found\r\n                        return { fileName: sourceMap.sources[sourceFileIndex], lineNumber: sourceCodeLine, columnNumber: sourceCodeColumn };\r\n                    }\r\n                    else if (columnIndex + 1 === columns.length) {\r\n                        // matching column not found, but line is correct\r\n                        return { fileName: sourceMap.sources[sourceFileIndex], lineNumber: sourceCodeLine, columnNumber: 0 };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // failed if reached\r\n        return { fileName: 'unknown', lineNumber: 0, columnNumber: 0 };\r\n    }\r\n    /**\r\n     * does the http get request to get the source map\r\n     * @param sourceMapLocation\r\n     * @param distPosition\r\n     */\r\n    getSourceMap(sourceMapLocation, distPosition) {\r\n        const req = new HttpRequest('GET', sourceMapLocation);\r\n        const distPositionKey = `${distPosition.fileName}:${distPosition.lineNumber}:${distPosition.columnNumber}`;\r\n        // if the specific log position is already in cache return it\r\n        if (this.logPositionCache.has(distPositionKey)) {\r\n            return this.logPositionCache.get(distPositionKey);\r\n        }\r\n        // otherwise check if the source map is already cached for given source map location\r\n        if (!this.sourceMapCache.has(sourceMapLocation)) {\r\n            if (!this.httpBackend) {\r\n                console.error('NGXLogger : Can\\'t get sourcemap because HttpBackend is not provided. You need to import HttpClientModule');\r\n                this.sourceMapCache.set(sourceMapLocation, of(null));\r\n            }\r\n            else {\r\n                // obtain the source map if not cached\r\n                this.sourceMapCache.set(sourceMapLocation, this.httpBackend.handle(req).pipe(filter((e) => e instanceof HttpResponse), map((httpResponse) => httpResponse.body), retry(3), shareReplay(1)));\r\n            }\r\n        }\r\n        // at this point the source map is cached, use it to get specific log position mapping\r\n        const logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(map((sourceMap) => {\r\n            // sourceMap can be null if HttpBackend is not provided for example\r\n            if (!sourceMap) {\r\n                return distPosition;\r\n            }\r\n            // map generated position to source position\r\n            return this.getMapping(sourceMap, distPosition);\r\n        }), catchError(() => of(distPosition)), shareReplay(1));\r\n        // store specific log position in cache for given dest position and return it\r\n        this.logPositionCache.set(distPositionKey, logPosition$);\r\n        return logPosition$;\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMapperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMapperService, deps: [{ token: i1.HttpBackend, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMapperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMapperService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMapperService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: i1.HttpBackend, decorators: [{\r\n                        type: Optional\r\n                    }] }];\r\n    } });\n\n/**\r\n * Injection token of logger metadata service\r\n */\r\nconst TOKEN_LOGGER_METADATA_SERVICE = 'TOKEN_LOGGER_METADATA_SERVICE';\n\nclass NGXLoggerMetadataService {\r\n    constructor(datePipe) {\r\n        this.datePipe = datePipe;\r\n    }\r\n    computeTimestamp(config) {\r\n        const defaultTimestamp = () => new Date().toISOString();\r\n        if (config.timestampFormat) {\r\n            if (!this.datePipe) {\r\n                console.error('NGXLogger : Can\\'t use timeStampFormat because DatePipe is not provided. You need to provide DatePipe');\r\n                return defaultTimestamp();\r\n            }\r\n            else {\r\n                return this.datePipe.transform(new Date(), config.timestampFormat);\r\n            }\r\n        }\r\n        return defaultTimestamp();\r\n    }\r\n    getMetadata(level, config, message, additional) {\r\n        const metadata = {\r\n            level: level,\r\n            additional: additional,\r\n        };\r\n        // The user can send a function\r\n        // This is useful in order to compute string concatenation only when the log will actually be written\r\n        if (message && typeof message === 'function') {\r\n            metadata.message = message();\r\n        }\r\n        else {\r\n            metadata.message = message;\r\n        }\r\n        metadata.timestamp = this.computeTimestamp(config);\r\n        return metadata;\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMetadataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMetadataService, deps: [{ token: i1$1.DatePipe, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMetadataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMetadataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMetadataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: i1$1.DatePipe, decorators: [{\r\n                        type: Optional\r\n                    }] }];\r\n    } });\n\n// I kept this class alive only to avoid a breaking change with the old version\r\n// This class does not implement anything so it is useless and the interface is enough\r\n/**\r\n * @deprecated this class does not implement anything thus being useless, you should rather implements @see INGXLoggerMonitor\r\n */\r\nclass NGXLoggerMonitor {\r\n}\n\n/**\r\n * Injection token of logger metadata service\r\n */\r\nconst TOKEN_LOGGER_RULES_SERVICE = 'TOKEN_LOGGER_RULES_SERVICE';\n\nclass NGXLoggerRulesService {\r\n    shouldCallWriter(level, config, message, additional) {\r\n        return !config.disableConsoleLogging && level >= config.level;\r\n    }\r\n    shouldCallServer(level, config, message, additional) {\r\n        return !!config.serverLoggingUrl && level >= config.serverLogLevel;\r\n    }\r\n    shouldCallMonitor(level, config, message, additional) {\r\n        // The default behavior is to call the monitor only if the writer or the server is called\r\n        return this.shouldCallWriter(level, config, message, additional) || this.shouldCallServer(level, config, message, additional);\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerRulesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerRulesService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerRulesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerRulesService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerRulesService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\n/**\r\n * Injection token of logger server service\r\n */\r\nconst TOKEN_LOGGER_SERVER_SERVICE = 'TOKEN_LOGGER_SERVER_SERVICE';\n\nclass NGXLoggerServerService {\r\n    constructor(httpBackend) {\r\n        this.httpBackend = httpBackend;\r\n    }\r\n    /**\r\n     * Transforms an error object into a readable string (taking only the stack)\r\n     * This is needed because JSON.stringify would return \"{}\"\r\n     * @param err the error object\r\n     * @returns The stack of the error\r\n     */\r\n    secureErrorObject(err) {\r\n        return err === null || err === void 0 ? void 0 : err.stack;\r\n    }\r\n    /**\r\n     * Transforms the additional parameters to avoid any json error when sending the data to the server\r\n     * Basically it just replaces unstringifiable object to a string mentioning an error\r\n     * @param additional The additional data to be sent\r\n     * @returns The additional data secured\r\n     */\r\n    secureAdditionalParameters(additional) {\r\n        if (additional === null || additional === undefined) {\r\n            return null;\r\n        }\r\n        return additional.map((next, idx) => {\r\n            try {\r\n                if (next instanceof Error) {\r\n                    return this.secureErrorObject(next);\r\n                }\r\n                // We just want to make sure the JSON can be parsed, we do not want to actually change the type\r\n                if (typeof next === 'object') {\r\n                    JSON.stringify(next);\r\n                }\r\n                return next;\r\n            }\r\n            catch (e) {\r\n                return `The additional[${idx}] value could not be parsed using JSON.stringify().`;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Transforms the message so that it can be sent to the server\r\n     * @param message the message to be sent\r\n     * @returns the message secured\r\n     */\r\n    secureMessage(message) {\r\n        try {\r\n            if (message instanceof Error) {\r\n                return this.secureErrorObject(message);\r\n            }\r\n            if (typeof message !== 'string') {\r\n                message = JSON.stringify(message, null, 2);\r\n            }\r\n        }\r\n        catch (e) {\r\n            message = 'The provided \"message\" value could not be parsed with JSON.stringify().';\r\n        }\r\n        return message;\r\n    }\r\n    /**\r\n     * Edits HttpRequest object before sending request to server\r\n     * @param httpRequest default request object\r\n     * @returns altered httprequest\r\n     */\r\n    alterHttpRequest(httpRequest) {\r\n        return httpRequest;\r\n    }\r\n    /**\r\n     * Sends request to server\r\n     * @param url\r\n     * @param logContent\r\n     * @param options\r\n     * @returns\r\n     */\r\n    logOnServer(url, logContent, options) {\r\n        if (!this.httpBackend) {\r\n            console.error('NGXLogger : Can\\'t log on server because HttpBackend is not provided. You need to import HttpClientModule');\r\n            return of(null);\r\n        }\r\n        // HttpBackend skips all HttpInterceptors\r\n        // They may log errors using this service causing circular calls\r\n        let defaultRequest = new HttpRequest('POST', url, logContent, options || {});\r\n        let finalRequest = of(defaultRequest);\r\n        const alteredRequest = this.alterHttpRequest(defaultRequest);\r\n        if (isObservable(alteredRequest)) {\r\n            finalRequest = alteredRequest;\r\n        }\r\n        else if (alteredRequest) {\r\n            finalRequest = of(alteredRequest);\r\n        }\r\n        else {\r\n            console.warn('NGXLogger : alterHttpRequest returned an invalid request. Using default one instead');\r\n        }\r\n        return finalRequest.pipe(concatMap(req => {\r\n            if (!req) {\r\n                console.warn('NGXLogger : alterHttpRequest returned an invalid request (observable). Using default one instead');\r\n                return this.httpBackend.handle(defaultRequest);\r\n            }\r\n            return this.httpBackend.handle(req);\r\n        }), filter(e => e instanceof HttpResponse), map((httpResponse) => httpResponse.body));\r\n    }\r\n    /**\r\n     * Customise the data sent to the API\r\n     * @param metadata the data provided by NGXLogger\r\n     * @returns the data that will be sent to the API in the body\r\n     */\r\n    customiseRequestBody(metadata) {\r\n        // In our API the body is not customised\r\n        return metadata;\r\n    }\r\n    sendToServer(metadata, config) {\r\n        // Copying metadata locally because we don't want to change the object for the caller\r\n        const localMetadata = Object.assign({}, metadata);\r\n        localMetadata.additional = this.secureAdditionalParameters(localMetadata.additional);\r\n        localMetadata.message = this.secureMessage(localMetadata.message);\r\n        // Allow users to customise the data sent to the API\r\n        const requestBody = this.customiseRequestBody(localMetadata);\r\n        const headers = config.customHttpHeaders || new HttpHeaders();\r\n        if (!headers.has('Content-Type')) {\r\n            headers.set('Content-Type', 'application/json');\r\n        }\r\n        this.logOnServer(config.serverLoggingUrl, requestBody, {\r\n            headers,\r\n            params: config.customHttpParams || new HttpParams(),\r\n            responseType: config.httpResponseType || 'json',\r\n            withCredentials: config.withCredentials || false,\r\n        }).pipe(catchError(err => {\r\n            // Do not use NGXLogger here because this could cause an infinite loop \r\n            console.error('NGXLogger: Failed to log on server', err);\r\n            return throwError(err);\r\n        })).subscribe();\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerServerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerServerService, deps: [{ token: i1.HttpBackend, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerServerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerServerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerServerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: i1.HttpBackend, decorators: [{\r\n                        type: Optional\r\n                    }] }];\r\n    } });\n\n/**\r\n * Injection token of logger writer service\r\n */\r\nconst TOKEN_LOGGER_WRITER_SERVICE = 'TOKEN_LOGGER_WRITER_SERVICE';\n\nvar NgxLoggerLevel;\r\n(function (NgxLoggerLevel) {\r\n    NgxLoggerLevel[NgxLoggerLevel[\"TRACE\"] = 0] = \"TRACE\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"DEBUG\"] = 1] = \"DEBUG\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"INFO\"] = 2] = \"INFO\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"LOG\"] = 3] = \"LOG\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"WARN\"] = 4] = \"WARN\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"ERROR\"] = 5] = \"ERROR\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"FATAL\"] = 6] = \"FATAL\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"OFF\"] = 7] = \"OFF\";\r\n})(NgxLoggerLevel || (NgxLoggerLevel = {}));\n\nconst DEFAULT_COLOR_SCHEME = [\r\n    'purple',\r\n    'teal',\r\n    'gray',\r\n    'gray',\r\n    'red',\r\n    'red',\r\n    'red'\r\n];\n\nclass NGXLoggerWriterService {\r\n    constructor(platformId) {\r\n        this.platformId = platformId;\r\n        /** List of functions called when preparing meta string */\r\n        this.prepareMetaStringFuncs = [\r\n            this.getTimestampToWrite,\r\n            this.getLevelToWrite,\r\n            this.getFileDetailsToWrite,\r\n            this.getContextToWrite,\r\n        ];\r\n        this.isIE = isPlatformBrowser(platformId) && navigator && navigator.userAgent &&\r\n            !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\\//) || navigator.userAgent.match(/Edge\\//));\r\n        this.logFunc = this.isIE ? this.logIE.bind(this) : this.logModern.bind(this);\r\n    }\r\n    getTimestampToWrite(metadata, config) {\r\n        return metadata.timestamp;\r\n    }\r\n    getLevelToWrite(metadata, config) {\r\n        return NgxLoggerLevel[metadata.level];\r\n    }\r\n    getFileDetailsToWrite(metadata, config) {\r\n        return config.disableFileDetails === true ? '' : `[${metadata.fileName}:${metadata.lineNumber}:${metadata.columnNumber}]`;\r\n    }\r\n    getContextToWrite(metadata, config) {\r\n        return config.context ? `{${config.context}}` : '';\r\n    }\r\n    /** Generate a \"meta\" string that is displayed before the content sent to the log function */\r\n    prepareMetaString(metadata, config) {\r\n        let metaString = '';\r\n        this.prepareMetaStringFuncs.forEach(prepareMetaStringFunc => {\r\n            const metaItem = prepareMetaStringFunc(metadata, config);\r\n            if (metaItem) {\r\n                metaString = metaString + ' ' + metaItem;\r\n            }\r\n        });\r\n        return metaString.trim();\r\n    }\r\n    /** Get the color to use when writing to console */\r\n    getColor(metadata, config) {\r\n        var _a;\r\n        const configColorScheme = (_a = config.colorScheme) !== null && _a !== void 0 ? _a : DEFAULT_COLOR_SCHEME;\r\n        // this is needed to avoid a build error\r\n        if (metadata.level === NgxLoggerLevel.OFF) {\r\n            return undefined;\r\n        }\r\n        return configColorScheme[metadata.level];\r\n    }\r\n    /** Log to the console specifically for IE */\r\n    logIE(metadata, config, metaString) {\r\n        // Coloring doesn't work in IE\r\n        // make sure additional isn't null or undefined so that ...additional doesn't error\r\n        const additional = metadata.additional || [];\r\n        switch (metadata.level) {\r\n            case NgxLoggerLevel.WARN:\r\n                console.warn(`${metaString} `, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.ERROR:\r\n            case NgxLoggerLevel.FATAL:\r\n                console.error(`${metaString} `, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.INFO:\r\n                console.info(`${metaString} `, metadata.message, ...additional);\r\n                break;\r\n            default:\r\n                console.log(`${metaString} `, metadata.message, ...additional);\r\n        }\r\n    }\r\n    /** Log to the console */\r\n    logModern(metadata, config, metaString) {\r\n        const color = this.getColor(metadata, config);\r\n        // make sure additional isn't null or undefined so that ...additional doesn't error\r\n        const additional = metadata.additional || [];\r\n        switch (metadata.level) {\r\n            case NgxLoggerLevel.WARN:\r\n                console.warn(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.ERROR:\r\n            case NgxLoggerLevel.FATAL:\r\n                console.error(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.INFO:\r\n                console.info(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            //  Disabling console.trace since the stack trace is not helpful. it is showing the stack trace of\r\n            // the console.trace statement\r\n            // case NgxLoggerLevel.TRACE:\r\n            //   console.trace(`%c${metaString}`, `color:${color}`, message, ...additional);\r\n            //   break;\r\n            case NgxLoggerLevel.DEBUG:\r\n                console.debug(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            default:\r\n                console.log(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n        }\r\n    }\r\n    /** Write the content sent to the log function to the console */\r\n    writeMessage(metadata, config) {\r\n        const metaString = this.prepareMetaString(metadata, config);\r\n        this.logFunc(metadata, config, metaString);\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerWriterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerWriterService, deps: [{ token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerWriterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerWriterService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerWriterService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [PLATFORM_ID]\r\n                    }] }];\r\n    } });\n\nclass NGXLogger {\r\n    constructor(config, configEngineFactory, metadataService, ruleService, mapperService, writerService, serverService) {\r\n        this.metadataService = metadataService;\r\n        this.ruleService = ruleService;\r\n        this.mapperService = mapperService;\r\n        this.writerService = writerService;\r\n        this.serverService = serverService;\r\n        this.configEngine = configEngineFactory.provideConfigEngine(config);\r\n    }\r\n    /** Get a readonly access to the level configured for the NGXLogger */\r\n    get level() {\r\n        return this.configEngine.level;\r\n    }\r\n    /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\r\n    get serverLogLevel() {\r\n        return this.configEngine.serverLogLevel;\r\n    }\r\n    trace(message, ...additional) {\r\n        this._log(NgxLoggerLevel.TRACE, message, additional);\r\n    }\r\n    debug(message, ...additional) {\r\n        this._log(NgxLoggerLevel.DEBUG, message, additional);\r\n    }\r\n    info(message, ...additional) {\r\n        this._log(NgxLoggerLevel.INFO, message, additional);\r\n    }\r\n    log(message, ...additional) {\r\n        this._log(NgxLoggerLevel.LOG, message, additional);\r\n    }\r\n    warn(message, ...additional) {\r\n        this._log(NgxLoggerLevel.WARN, message, additional);\r\n    }\r\n    error(message, ...additional) {\r\n        this._log(NgxLoggerLevel.ERROR, message, additional);\r\n    }\r\n    fatal(message, ...additional) {\r\n        this._log(NgxLoggerLevel.FATAL, message, additional);\r\n    }\r\n    /** @deprecated customHttpHeaders is now part of the config, this should be updated via @see updateConfig */\r\n    setCustomHttpHeaders(headers) {\r\n        const config = this.getConfigSnapshot();\r\n        config.customHttpHeaders = headers;\r\n        this.updateConfig(config);\r\n    }\r\n    /** @deprecated customHttpParams is now part of the config, this should be updated via @see updateConfig */\r\n    setCustomParams(params) {\r\n        const config = this.getConfigSnapshot();\r\n        config.customHttpParams = params;\r\n        this.updateConfig(config);\r\n    }\r\n    /** @deprecated withCredentials is now part of the config, this should be updated via @see updateConfig */\r\n    setWithCredentialsOptionValue(withCredentials) {\r\n        const config = this.getConfigSnapshot();\r\n        config.withCredentials = withCredentials;\r\n        this.updateConfig(config);\r\n    }\r\n    /**\r\n     * Register a INGXLoggerMonitor that will be trigger when a log is either written or sent to server\r\n     *\r\n     * There is only one monitor, registering one will overwrite the last one if there was one\r\n     * @param monitor\r\n     */\r\n    registerMonitor(monitor) {\r\n        this._loggerMonitor = monitor;\r\n    }\r\n    /** Set config of logger\r\n     *\r\n     * Warning : This overwrites all the config, if you want to update only one property, you should use @see getConfigSnapshot before\r\n     */\r\n    updateConfig(config) {\r\n        this.configEngine.updateConfig(config);\r\n    }\r\n    partialUpdateConfig(partialConfig) {\r\n        this.configEngine.partialUpdateConfig(partialConfig);\r\n    }\r\n    /** Get config of logger */\r\n    getConfigSnapshot() {\r\n        return this.configEngine.getConfig();\r\n    }\r\n    _log(level, message, additional = []) {\r\n        const config = this.configEngine.getConfig();\r\n        const shouldCallWriter = this.ruleService.shouldCallWriter(level, config, message, additional);\r\n        const shouldCallServer = this.ruleService.shouldCallServer(level, config, message, additional);\r\n        const shouldCallMonitor = this.ruleService.shouldCallMonitor(level, config, message, additional);\r\n        if (!shouldCallWriter && !shouldCallServer && !shouldCallMonitor) {\r\n            // If nothing is to be called we return\r\n            return;\r\n        }\r\n        const metadata = this.metadataService.getMetadata(level, config, message, additional);\r\n        this.mapperService.getLogPosition(config, metadata).pipe(take(1)).subscribe(logPosition => {\r\n            if (logPosition) {\r\n                metadata.fileName = logPosition.fileName;\r\n                metadata.lineNumber = logPosition.lineNumber;\r\n                metadata.columnNumber = logPosition.columnNumber;\r\n            }\r\n            if (shouldCallMonitor && this._loggerMonitor) {\r\n                this._loggerMonitor.onLog(metadata, config);\r\n            }\r\n            if (shouldCallWriter) {\r\n                this.writerService.writeMessage(metadata, config);\r\n            }\r\n            if (shouldCallServer) {\r\n                this.serverService.sendToServer(metadata, config);\r\n            }\r\n        });\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLogger.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLogger, deps: [{ token: TOKEN_LOGGER_CONFIG }, { token: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY }, { token: TOKEN_LOGGER_METADATA_SERVICE }, { token: TOKEN_LOGGER_RULES_SERVICE }, { token: TOKEN_LOGGER_MAPPER_SERVICE }, { token: TOKEN_LOGGER_WRITER_SERVICE }, { token: TOKEN_LOGGER_SERVER_SERVICE }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLogger.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLogger, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLogger, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root'\r\n                }]\r\n        }], ctorParameters: function () {\r\n        return [{ type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_CONFIG]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_CONFIG_ENGINE_FACTORY]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_METADATA_SERVICE]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_RULES_SERVICE]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_MAPPER_SERVICE]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_WRITER_SERVICE]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_SERVER_SERVICE]\r\n                    }] }];\r\n    } });\n\n/**\r\n * CustomNGXLoggerService is designed to allow users to get a new instance of a logger\r\n */\r\nclass CustomNGXLoggerService {\r\n    constructor(logger, configEngineFactory, metadataService, ruleService, mapperService, writerService, serverService) {\r\n        this.logger = logger;\r\n        this.configEngineFactory = configEngineFactory;\r\n        this.metadataService = metadataService;\r\n        this.ruleService = ruleService;\r\n        this.mapperService = mapperService;\r\n        this.writerService = writerService;\r\n        this.serverService = serverService;\r\n    }\r\n    /**\r\n     * Create an instance of a logger\r\n     * @deprecated this function does not have all the features, @see getNewInstance for every params available\r\n     * @param config\r\n     * @param serverService\r\n     * @param logMonitor\r\n     * @param mapperService\r\n     * @returns\r\n     */\r\n    create(config, serverService, logMonitor, mapperService) {\r\n        return this.getNewInstance({\r\n            config,\r\n            serverService,\r\n            logMonitor,\r\n            mapperService\r\n        });\r\n    }\r\n    /**\r\n     * Get a new instance of NGXLogger\r\n     * @param params list of optional params to use when creating an instance of NGXLogger\r\n     * @returns the new instance of NGXLogger\r\n     */\r\n    getNewInstance(params) {\r\n        var _a, _b, _c, _d, _e, _f, _g;\r\n        const logger = new NGXLogger((_a = params === null || params === void 0 ? void 0 : params.config) !== null && _a !== void 0 ? _a : this.logger.getConfigSnapshot(), (_b = params === null || params === void 0 ? void 0 : params.configEngineFactory) !== null && _b !== void 0 ? _b : this.configEngineFactory, (_c = params === null || params === void 0 ? void 0 : params.metadataService) !== null && _c !== void 0 ? _c : this.metadataService, (_d = params === null || params === void 0 ? void 0 : params.ruleService) !== null && _d !== void 0 ? _d : this.ruleService, (_e = params === null || params === void 0 ? void 0 : params.mapperService) !== null && _e !== void 0 ? _e : this.mapperService, (_f = params === null || params === void 0 ? void 0 : params.writerService) !== null && _f !== void 0 ? _f : this.writerService, (_g = params === null || params === void 0 ? void 0 : params.serverService) !== null && _g !== void 0 ? _g : this.serverService);\r\n        if (params === null || params === void 0 ? void 0 : params.partialConfig) {\r\n            logger.partialUpdateConfig(params.partialConfig);\r\n        }\r\n        if (params === null || params === void 0 ? void 0 : params.logMonitor) {\r\n            logger.registerMonitor(params.logMonitor);\r\n        }\r\n        return logger;\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ CustomNGXLoggerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CustomNGXLoggerService, deps: [{ token: NGXLogger }, { token: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY }, { token: TOKEN_LOGGER_METADATA_SERVICE }, { token: TOKEN_LOGGER_RULES_SERVICE }, { token: TOKEN_LOGGER_MAPPER_SERVICE }, { token: TOKEN_LOGGER_WRITER_SERVICE }, { token: TOKEN_LOGGER_SERVER_SERVICE }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ CustomNGXLoggerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CustomNGXLoggerService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CustomNGXLoggerService, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root'\r\n                }]\r\n        }], ctorParameters: function () {\r\n        return [{ type: NGXLogger }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_CONFIG_ENGINE_FACTORY]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_METADATA_SERVICE]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_RULES_SERVICE]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_MAPPER_SERVICE]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_WRITER_SERVICE]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_SERVER_SERVICE]\r\n                    }] }];\r\n    } });\n\nclass LoggerModule {\r\n    static forRoot(config, customProvider) {\r\n        if (!customProvider) {\r\n            customProvider = {};\r\n        }\r\n        // default config provider\r\n        if (!customProvider.configProvider) {\r\n            customProvider.configProvider = { provide: TOKEN_LOGGER_CONFIG, useValue: config || {} };\r\n        }\r\n        else {\r\n            // if the user provided its own config, we just make sure the injection token is correct\r\n            if (customProvider.configProvider.provide !== TOKEN_LOGGER_CONFIG) {\r\n                throw new Error(`Wrong injection token for configProvider, it should be ${TOKEN_LOGGER_CONFIG} and you used ${customProvider.configProvider.provide}`);\r\n            }\r\n        }\r\n        // default configEngine provider\r\n        if (!customProvider.configEngineFactoryProvider) {\r\n            customProvider.configEngineFactoryProvider = { provide: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, useClass: NGXLoggerConfigEngineFactory };\r\n        }\r\n        else {\r\n            // if the user provided its own configEngineFactory, we just make sure the injection token is correct\r\n            if (customProvider.configEngineFactoryProvider.provide !== TOKEN_LOGGER_CONFIG_ENGINE_FACTORY) {\r\n                throw new Error(`Wrong injection token for configEngineFactoryProvider, it should be '${TOKEN_LOGGER_CONFIG_ENGINE_FACTORY}' and you used '${customProvider.configEngineFactoryProvider.provide}'`);\r\n            }\r\n        }\r\n        // default metadata provider\r\n        if (!customProvider.metadataProvider) {\r\n            customProvider.metadataProvider = { provide: TOKEN_LOGGER_METADATA_SERVICE, useClass: NGXLoggerMetadataService };\r\n        }\r\n        else {\r\n            // if the user provided its own metadataService, we just make sure the injection token is correct\r\n            if (customProvider.metadataProvider.provide !== TOKEN_LOGGER_METADATA_SERVICE) {\r\n                throw new Error(`Wrong injection token for metadataProvider, it should be '${TOKEN_LOGGER_METADATA_SERVICE}' and you used '${customProvider.metadataProvider.provide}'`);\r\n            }\r\n        }\r\n        // default rule provider\r\n        if (!customProvider.ruleProvider) {\r\n            customProvider.ruleProvider = { provide: TOKEN_LOGGER_RULES_SERVICE, useClass: NGXLoggerRulesService };\r\n        }\r\n        else {\r\n            // if the user provided its own ruleService, we just make sure the injection token is correct\r\n            if (customProvider.ruleProvider.provide !== TOKEN_LOGGER_RULES_SERVICE) {\r\n                throw new Error(`Wrong injection token for ruleProvider, it should be '${TOKEN_LOGGER_RULES_SERVICE}' and you used '${customProvider.ruleProvider.provide}'`);\r\n            }\r\n        }\r\n        // default mapper provider\r\n        if (!customProvider.mapperProvider) {\r\n            customProvider.mapperProvider = { provide: TOKEN_LOGGER_MAPPER_SERVICE, useClass: NGXLoggerMapperService };\r\n        }\r\n        else {\r\n            // if the user provided its own mapperService, we just make sure the injection token is correct\r\n            if (customProvider.mapperProvider.provide !== TOKEN_LOGGER_MAPPER_SERVICE) {\r\n                throw new Error(`Wrong injection token for mapperProvider, it should be '${TOKEN_LOGGER_MAPPER_SERVICE}' and you used '${customProvider.mapperProvider.provide}'`);\r\n            }\r\n        }\r\n        // default writer provider\r\n        if (!customProvider.writerProvider) {\r\n            customProvider.writerProvider = { provide: TOKEN_LOGGER_WRITER_SERVICE, useClass: NGXLoggerWriterService };\r\n        }\r\n        else {\r\n            // if the user provided its own writerService, we just make sure the injection token is correct\r\n            if (customProvider.writerProvider.provide !== TOKEN_LOGGER_WRITER_SERVICE) {\r\n                throw new Error(`Wrong injection token for writerProvider, it should be '${TOKEN_LOGGER_WRITER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\r\n            }\r\n        }\r\n        // default server provider\r\n        if (!customProvider.serverProvider) {\r\n            customProvider.serverProvider = { provide: TOKEN_LOGGER_SERVER_SERVICE, useClass: NGXLoggerServerService };\r\n        }\r\n        else {\r\n            // if the user provided its own serverService, we just make sure the injection token is correct\r\n            if (customProvider.serverProvider.provide !== TOKEN_LOGGER_SERVER_SERVICE) {\r\n                throw new Error(`Wrong injection token for serverProvider, it should be '${TOKEN_LOGGER_SERVER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\r\n            }\r\n        }\r\n        return {\r\n            ngModule: LoggerModule,\r\n            providers: [\r\n                NGXLogger,\r\n                customProvider.configProvider,\r\n                customProvider.configEngineFactoryProvider,\r\n                customProvider.metadataProvider,\r\n                customProvider.ruleProvider,\r\n                customProvider.mapperProvider,\r\n                customProvider.writerProvider,\r\n                customProvider.serverProvider,\r\n                CustomNGXLoggerService,\r\n            ]\r\n        };\r\n    }\r\n    static forChild() {\r\n        // todo : this forChild is useless for now because nothing is different from forRoot.\r\n        // This should be implemented so that user can change the providers in the forChild\r\n        return {\r\n            ngModule: LoggerModule,\r\n        };\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ LoggerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\n/** @nocollapse */ /** @nocollapse */ LoggerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, imports: [CommonModule] });\r\n/** @nocollapse */ /** @nocollapse */ LoggerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, imports: [[\r\n            CommonModule\r\n        ]] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    imports: [\r\n                        CommonModule\r\n                    ],\r\n                }]\r\n        }] });\n\n/*\r\n * Public API Surface of ngx-logger\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { CustomNGXLoggerService, DEFAULT_COLOR_SCHEME, LoggerModule, NGXLogger, NGXLoggerConfigEngine, NGXLoggerConfigEngineFactory, NGXLoggerMapperService, NGXLoggerMetadataService, NGXLoggerMonitor, NGXLoggerRulesService, NGXLoggerServerService, NGXLoggerWriterService, NgxLoggerLevel, TOKEN_LOGGER_CONFIG, TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, TOKEN_LOGGER_MAPPER_SERVICE, TOKEN_LOGGER_METADATA_SERVICE, TOKEN_LOGGER_RULES_SERVICE, TOKEN_LOGGER_SERVER_SERVICE, TOKEN_LOGGER_WRITER_SERVICE };\n"]},"metadata":{},"sourceType":"module"}